#!/usr/bin/env ruby

require 'optparse'
require "bundler/setup"
require 'maze'

require 'io/console'

# Reads keypresses from the user including 2 and 3 escape character sequences.
def read_char
  STDIN.echo = false
  STDIN.raw!

  input = STDIN.getc.chr
  if input == "\e" then
    input << STDIN.read_nonblock(3) rescue nil
    input << STDIN.read_nonblock(2) rescue nil
  end
ensure
  STDIN.echo = true
  STDIN.cooked!

  return input
end

visualization_modes = [:run, :runsegment, :segment, :step]

# Initialize random number generator
srand
seed = srand
srand(seed)

# default options
options = {
  type: :ortho, 
  grid_size: [4, 4],
  ascii: true,
  cell_size: 1, 
  algorithm: :gt1,
  visualize: false,
  highlight: true,
  seed: seed,
  image: false,
  png_cell: 50,
  png_wall: 1,
  png_border: 0,
}

parser = OptionParser.new do |opts|
  opts.banner = "
Maze generator

Usage: #{File.basename $0} [options]
"
  opts.separator "\nGrid options:"

  opts.on('-t', '--type TYPE', Maze::Factory.types, 'The type of the maze.', "One of #{Maze::Factory.types.join(', ')}") do |type|
    options[:type] = type
  end
  opts.on('-g', '--grid-size ROWS[,COLUMNS]', Array, 'The number of rows and columns of the grid') do |v|
    options[:grid_size] = v.first(2).map(&:to_i)
    options[:grid_size][1] = options[:grid_size].first unless options[:grid_size][1]
  end
  
  opts.separator "\nAlgorithm options:"

  opts.on('-a', '--algorithm ALGORITHM', Maze::Factory.algorithms, 'The algorithm to generate the maze.', "One of #{Maze::Factory.algorithms.join(', ')}") do |algorithm|
    options[:algorithm] = algorithm
  end
  opts.on('-S', '--seed SEED', Integer, 'Set random seed') do |seed|
    options[:seed] = seed
    srand(seed)
  end
  
  opts.separator "\nASCII Options:"
  
  opts.on('--[no-]ascii', 'Render the maze with ASCII on the terminal.') do |ascii|
    options[:ascii] = ascii
  end
  opts.on('-c', '--cell-size SIZE', Integer, 'The size of the cell') do |cell_size|
    options[:cell_size] = cell_size
  end

  opts.separator "\nPNG Options:"
  
  opts.on('--[no-]image', 'Render the maze as PNG image.') do |image|
    options[:image] = image
  end
  opts.on('--cell-width [PIXEL]', Integer, 'The width of a cell.') do |px|
    options[:png_cell] = px
  end
  opts.on('--line [PIXEL]', Integer, 'The width of the walls.') do |px|
    options[:png_wall] = px
  end
  opts.on('--border [PIXEL]', Integer, 'The width of the border around the maze.') do |px|
    options[:png_border] = px
  end  
  
  opts.separator "\nMisc:"

  opts.on('-v', '--visualize [MODE]', visualization_modes, 'Visualize the progress of the algorithm', "One of #{visualization_modes.join(', ')}") do |mode|
    options[:visualize] = mode || :run
  end
  opts.on('--off', 'Do not highlight the current cells') do
    options[:highlight] = false
  end

  opts.separator ""
end

parser.parse!(ARGV)
options[:visualize] = false unless options[:ascii]

# Initialize the grid and a ascii formatter
factory = Maze::Factory.new options[:type]
grid = factory.create_grid *options[:grid_size]
formatter = factory.create_ascii_formatter cell_size: options[:cell_size]

# Instanziate the algorithm
algorithm = factory.create_algorithm options[:algorithm]

# Run the algorithm on the grid
algorithm.on grid do |stat|
  next unless options[:visualize]

  # print the maze
  highlighted_cells = options[:highlight] ? stat.active : []
  puts formatter.render grid, highlighted_cells
  puts stat.info if stat.info
  sleep algorithm.speed
  sleep 1 if options[:visualize] == :runsegment && stat.segment
  
  # wait for keystroke ?
  if (options[:visualize] == :segment && stat.segment || options[:visualize] == :step)
    break if read_char == "\e"
  end
end

if options[:ascii]
  puts formatter.render grid
end

puts algorithm.status
puts "Random seed: #{options[:seed]}"

if options[:image]
  png_formatter = factory.create_png_formatter cell_size: options[:png_cell], border: options[:png_border], thickness: options[:png_wall]
  image = png_formatter.render grid
  image.save "maze.png"
  puts "Maze 'maze.png' saved."
end
