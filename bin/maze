#!/usr/bin/env ruby

require 'optparse'
require "bundler/setup"
require 'maze'

require 'io/console'

# Reads keypresses from the user including 2 and 3 escape character sequences.
def read_char
  STDIN.echo = false
  STDIN.raw!

  input = STDIN.getc.chr
  if input == "\e" then
    input << STDIN.read_nonblock(3) rescue nil
    input << STDIN.read_nonblock(2) rescue nil
  end
ensure
  STDIN.echo = true
  STDIN.cooked!

  return input
end

algorithms = {
  bt:  { class: Maze::Algorithm::BinaryTree,    configurations: [] },
  ab:  { class: Maze::Algorithm::AldousBorder,  configurations: [] },
  sw:  { class: Maze::Algorithm::Sidewinder,    configurations: [] },
  gt:  { class: Maze::Algorithm::GrowingTree,   configurations: [
    Proc.new {|active| active.last },
    Proc.new {|active| active.sample },
    Proc.new {|active| (rand(2) == 0) ? active.last : active.sample },
  ] },
}

types = {
  delta: { grid: Maze::Grid::Delta, ascii_formatter: Maze::Formatter::Ascii::Delta },
  ortho: { grid: Maze::Grid::Ortho, ascii_formatter: Maze::Formatter::Ascii::Ortho },
  sigma: { grid: Maze::Grid::Sigma, ascii_formatter: Maze::Formatter::Ascii::Sigma },
}

visualization_modes = [:run, :runsegment, :segment, :step]

# default options
options = {
  type: :ortho, 
  grid_size: [4, 4],
  cell_size: 1, 
  algorithm: algorithms[:gt],
  algorithm_configuration: 0,
  visualize: false,
  highlight: true,
}

parser = OptionParser.new do |opts|
  opts.banner = "
Maze generator

Usage: #{File.basename $0} [options]

"
  opts.separator "\nGrid options:\n\n"

  opts.on('-t', '--type TYPE', types.keys, 'The type of the maze.', "One of #{types.keys.join(', ')}") do |type|
    options[:type] = type
  end
  opts.on('-g', '--grid-size ROWS[,COLUMNS]', Array, 'The number of rows and columns of the grid') do |v|
    options[:grid_size] = v.first(2).map(&:to_i)
    options[:grid_size][1] = options[:grid_size].first unless options[:grid_size][1]
  end
  opts.on('-c', '--cell-size SIZE', Integer, 'The size of the cell') do |cell_size|
    options[:cell_size] = cell_size
  end
  
  opts.separator "\nAlgorithm options:\n\n"

  opts.on('-a', '--algorithm ALGORITHM', algorithms.keys, 'The algorithm to generate the maze.', "One of #{algorithms.keys.join(', ')}") do |algorithm|
    options[:algorithm] = algorithms[algorithm]
  end
  opts.on('--conf NUMBER', Integer, 'Choose a configuration for an algorithm', 'Configurations exists for:', %Q%#{algorithms.map{|k,v| "#{k}: #{v[:configurations].size}" unless v[:configurations].empty?}.compact.join(', ')}%) do |conf|
    options[:algorithm_configuration] = conf-1
  end
  opts.on('-S', '--seed SEED', Integer, 'Set random seed') do |seed|
    srand(seed)
  end
  
  opts.separator "\nMisc:\n\n"

  opts.on('-v', '--visualize [MODE]', visualization_modes, 'Visualize the progress of the algorithm', "One of #{visualization_modes.join(', ')}") do |mode|
    options[:visualize] = mode || :run
  end
  opts.on('--off', 'Do not highlight the current cells') do
    options[:highlight] = false
  end

  opts.separator ""
end

parser.parse!(ARGV)

# Initialize the grid
grid_class = types[options[:type]][:grid]
formatter_class = types[options[:type]][:ascii_formatter]
grid = grid_class.new *options[:grid_size]
formatter = formatter_class.new cell_size: options[:cell_size]

# Instanziate and optionally configure the algorithm
algorithm = options[:algorithm][:class].new
unless options[:algorithm][:configurations].empty?
  algorithm.configure options[:algorithm][:configurations][options[:algorithm_configuration]]
end

# Run the algorithm on the grid
algorithm.on grid do |stat|
  next unless options[:visualize]

  # print the maze
  highlighted_cells = options[:highlight] ? stat.active : []
  puts formatter.render grid, highlighted_cells
  puts stat.info if stat.info
  sleep algorithm.speed
  sleep 1 if options[:visualize] == :runsegment && stat.segment
  
  # wait for keystroke ?
  if (options[:visualize] == :segment && stat.segment || options[:visualize] == :step)
    break if read_char == "\e"
  end
end

puts formatter.render grid
puts algorithm.status
